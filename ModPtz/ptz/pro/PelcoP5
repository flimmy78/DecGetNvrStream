Protocol = {}

-- 表示数值可以用16或10进制(最小值，最大值)
Protocol.Attr = 
{
	-- 协议的显示名称,不能超过16字符，目前暂不支持中文
	Name = "PELCOP5",	
		
	-- 指明是云台协议还是矩阵协议，使用"PTZ", "MATRIX"表示
	Type = "PTZ",
	
	-- 以ms为单位
	Internal = 200,
				
	-- 没有对应的地址范围，请都设成0xff
	-- 云台地址范围
	CamAddrRange 		= {0x00, 0x1F}, 
	-- 监视地址范围
	MonAddrRange		= {0x00, 0xFF},	
	-- 预置点范围
	PresetRange 		= {0x00, 0xff},
	-- 自动巡航线路范围
	TourRange		= {0x01, 0xff},
	-- 轨迹线路范围
	PatternRange		= {0x01, 0xff},
	-- 垂直速度范围
	TileSpeedRange 		= {0x01, 0x3F},
	-- 水平速度范围
	PanSpeedRange 		= {0x01, 0x3F},
	
	-- 辅助范围
	AuxRange 		= {0x01, 0x08},
}

Protocol.CommandAttr =
{
	-- 协议中需要更改的位置，用LUA下标表示，即下标从１开始,用10进制表示
	AddrPos 		= 2, 
	PresetPos 		= 6, 
	TileSpeedPos 		= 6,
	PanSpeedPos 		= 5,
	AuxPos 			= 6,
}

Protocol.Command = 
{
	-- 写具体协议时只能用16进制或字符表示,没有的话就注释掉
	Start= 
	{
		--写上下左右, 左上，左下，右上，右下
		TileUp 		= {0xA0, 0x00, 0x00, 0x08, 0x00, 0x00, 0xAF, 0x00},
		TileDown 	= {0xA0, 0x00, 0x00, 0x10, 0x00, 0x00, 0xAF, 0x00},
		PanLeft 	= {0xA0, 0x00, 0x00, 0x04, 0x00, 0x00, 0xAF, 0x00},
		PanRight 	= {0xA0, 0x00, 0x00, 0x02, 0x00, 0x00, 0xAF, 0x00},
		LeftUp 		= {0xA0, 0x00, 0x00, 0x0C, 0x00, 0x00, 0xAF, 0x00},
		LeftDown 	= {0xA0, 0x00, 0x00, 0x14, 0x00, 0x00, 0xAF, 0x00},
		RightUp		= {0xA0, 0x00, 0x00, 0x0A, 0x00, 0x00, 0xAF, 0x00},
		RightDown = {0xA0, 0x00, 0x00, 0x12, 0x00, 0x00, 0xAF, 0x00},

		ZoomWide 	= {0xA0, 0x00, 0x00, 0x40, 0x00, 0x00, 0xAF, 0x00},
		ZoomTele 	= {0xA0, 0x00, 0x00, 0x20, 0x00, 0x00, 0xAF, 0x00},
		FocusNear	= {0xA0, 0x00, 0x02, 0x00, 0x00, 0x00, 0xAF, 0x00},
		FocusFar 	= {0xA0, 0x00, 0x01, 0x00, 0x00, 0x00, 0xAF, 0x00},
		IrisSmall = {0xA0, 0x00, 0x08, 0x00, 0x00, 0x00, 0xAF, 0x00},
		IrisLarge = {0xA0, 0x00, 0x04, 0x00, 0x00, 0x00, 0xAF, 0x00},
			
		-- 预置点操作（设置，清除，转置)
		SetPreset 	= {0xA0, 0x00, 0x00, 0x03, 0x00, 0x00, 0xAF, 0x00},
		--ClearPreset	= {0xA0, 0x00, 0x00, 0x05, 0x00, 0x00, 0xAF, 0x00},
		GoToPreset 	= {0xA0, 0x00, 0x00, 0x07, 0x00, 0x00, 0xAF, 0x00},
			
		-- 水平旋转，
		--[[
		AutoPanOn	= {0xA0, 0x00, 0x00, 0x07, 0x00, 0x63, 0xAF, 0x00},
		AutoPanOff= {0xA0, 0x00, 0x00, 0x07, 0x00, 0x60, 0xAF, 0x00},
		--]]
			
		-- 自动扫描，在预先设置的边界中间转动
		--[[
		SetLeftLimit 	= {0xA0, 0x00, 0x00, 0x03, 0x00, 0x5C, 0xAF, 0x00},
		SetRightLimit	= {0xA0, 0x00, 0x00, 0x03, 0x00, 0x5D, 0xAF, 0x00},
		AutoScanOn 		= {0xA0, 0x00, 0x00, 0x07, 0x00, 0x46, 0xAF, 0x00},
		AutoScanOff		= {0xA0, 0x00, 0x00, 0x07, 0x00, 0x60, 0xAF, 0x00},
		--]]
		
		AuxOn 		= {0xA0, 0x00, 0x00, 0x09, 0x00, 0xff, 0xAF, 0x00},
		AuxOff 		= {0xA0, 0x00, 0x00, 0x0B, 0x00, 0xff, 0xAF, 0x00},
	},
	Stop = 
	{
		TileUp 		= {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
		TileDown 	= {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
		PanLeft 	= {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
		PanRight 	= {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
		LeftUp 		= {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
		LeftDown 	= {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
		RightUp		= {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
		RightDown = {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
		
		ZoomWide 	= {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
		ZoomTele 	= {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
		FocusNear = {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
		FocusFar 	= {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
		IrisSmall = {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
		IrisLarge = {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAF, 0x00},
	},
}

Protocol.Checksum = function (s)
	local value = s[1];
	for i = 2, 7 do
		value = bits.bxor(value,s[i]);
	end;
	s[8] = math.mod(value, 256);
	return s;
end;

Protocol.SpeedProcess = function(s, ver, hor)
	if s[4] ~= 0x00 and ver ~= 0x00 then
	s[6] = ver;
	end;
	if s[4] ~= 0x00 and hor ~= 0x00 then
	s[5] = hor;
	end;
	return s;
end;

Protocol.AuxProcess = function(s,num)
        if s[6] == 0xff then 
           local NewAux = math.mod(num,8)
              if NewAux == 0 then
              NewAux = 8;
              else
              NewAux = math.mod(num,8);
              end;
        s[6] = NewAux;
        end;
        return s;
end

---------------------位运算 异或-------------
bits = {};
bits.bxor = function (a, b)
	local c=0;
	local m=0;
	local n=0;
	for i=1, 32 do
		m=math.mod(a,2);
		n=math.mod(b,2);
		if m~=n then
			c=c+2^(i-1);
		end;
		if m==1 then
			a=a-1;
		end;
		if n==1 then
			b=b-1;
		end;
		a=a/2;
		b=b/2;
	end;
	return c;
end;
------------------------end-----------------------
